 **Line Segments**   
Given any two points <img src="https://render.githubusercontent.com/render/math?math=p_ {1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_ {2}">, then their convex combination is described as <img src="https://render.githubusercontent.com/render/math?math=\alpha"> <img src="https://render.githubusercontent.com/render/math?math=p_ {1}"> + <img src="https://render.githubusercontent.com/render/math?math=(1 - \alpha)p_{2}">
 Or to put it simply, convex combination of two points is the set of points lying on the line joining the two points. A directed segment <img src="https://render.githubusercontent.com/render/math?math=\vec{p_ {1}p_ {2}}"> can be thought of vector from <img src="https://render.githubusercontent.com/render/math?math=p_ {1}"> to <img src="https://render.githubusercontent.com/render/math?math=p_{2}">. When we want to know relative orientation of line segments, or if given line segments intersect or not, notion of cross product of two vectors helps. 
 Given two vectors <img src="https://render.githubusercontent.com/render/math?math=p_ {1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_ {2}">, we can interpret the cross product <img src="https://render.githubusercontent.com/render/math?math=p_ {1}">  <img src="https://render.githubusercontent.com/render/math?math=p_ {2}"> as the signed area of the parallelogram formed by the points <img src="https://render.githubusercontent.com/render/math?math= (0,0), p_{1}, p_{2}"> , and  <img src="https://render.githubusercontent.com/render/math?math=p_{1}+p_{2} = (x_{1} + x_{2}, y_{1}+ y_{2})">. An equivalent definition is given by determinant of the matrix,
 <img src="https://render.githubusercontent.com/render/math?math=p_{1} x p_{2}"> = det<img src="https://render.githubusercontent.com/render/math?math=x_{1}y_{2} - x_{2}y_{1}">
Now, positive cross product implies that  <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> is clockwise from  <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> and vice versa. If cross product is zero, then the vectors are collinear(or parallel, if not taken from a common point). The notion of cross product is useful in :
 1. **Determining whether consecutive segments turn left or right**  
 2. **Determining whether two line segments intersect**   
 
 To determine whether two line segments intersect, we check whether each segment *straddles* the line containing the other. A segment <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}">straddles a line if point <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> lies on one side of the line and point <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> lies on the other side. A boundary case arises if <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> or <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> lies directly on the line. Two line segments intersect if and only if either (or both) of the following conditions holds:  
 1. Each segment straddles the line containing the other.  
 2. An endpoint of one segment lies on the other segment.    
(This condition comes from the boundary case.)
The following procedures implement this idea. SEGMENTS -INTERSECT returns TRUE if segments <img src="https://render.githubusercontent.com/render/math?math=p_ {1}"> <img src="https://render.githubusercontent.com/render/math?math=p_ {2}"> and <img src="https://render.githubusercontent.com/render/math?math=p_ {3}"><img src="https://render.githubusercontent.com/render/math?math=p_{4}"> intersect and FALSE if they do not. It calls the subroutines DIRECTION , which computes relative orientations using the cross- product method above, and ON-SEGMENT , which determines whether a point known to be colinear with a segment lies on that segment.
  
SEGMENTS -INTERSECT (<img src="https://render.githubusercontent.com/render/math?math=(p_ {1},p_{2},p_ {3},p_ {4})">    
1  <img src="https://render.githubusercontent.com/render/math?math=d_ {1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math=(p_{3},p_{4},p_{1})">   
2  <img src="https://render.githubusercontent.com/render/math?math=d_ {2}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_ {3},p_ {4},p_{1})">  
3  <img src="https://render.githubusercontent.com/render/math?math=d_ {1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_{3},p_{4},p_{1})">  
4  <img src="https://render.githubusercontent.com/render/math?math=d_ {1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_{3},p_{4},p_{1})">  
5 if <img src="https://render.githubusercontent.com/render/math?math=d_ {1} > 0">and <img src="https://render.githubusercontent.com/render/math?math=d_ {2} < 0"> or <img src="https://render.githubusercontent.com/render/math?math=d_ {1} < 0">  and <img src="https://render.githubusercontent.com/render/math?math=d_ {2} > 0">// and
<img src="https://render.githubusercontent.com/render/math?math=d_ {3} > 0"> and <img src="https://render.githubusercontent.com/render/math?math=d_ {4} < 0"> or <img src="https://render.githubusercontent.com/render/math?math=d_ {3} < 0"> and <img src="https://render.githubusercontent.com/render/math?math=d_ {4} > 0">  
6 return TRUE  
7 elseif <img src="https://render.githubusercontent.com/render/math?math=d_ {1} == 0"> and ON-SEGMENT <img src="https://render.githubusercontent.com/render/math?math=p_ {3},p_{4},p _{1}">   
8 return TRUE  
9 elseif <img src="https://render.githubusercontent.com/render/math?math=d_ {2} == 0"> and ON-SEGMENT <img src="https://render.githubusercontent.com/render/math?math=p_ {3},p_{4},p _{2}">   
10 return TRUE  
11 elseif <img src="https://render.githubusercontent.com/render/math?math=d_ {3} == 0"> and ON-SEGMENT <img src="https://render.githubusercontent.com/render/math?math=p_ {1},p_{2},p _{3}">  
12 return TRUE  
13 elseif <img src="https://render.githubusercontent.com/render/math?math=d_ {4} == 0"> and ON-SEGMENT <img src="https://render.githubusercontent.com/render/math?math=p_ {1},p_{2},p _{4}">  
14 return TRUE  
15 else return FALSE  
DIRECTION <img src="https://render.githubusercontent.com/render/math?math=p_ {i},p_{j},p _{k}">  
1 return <img src="https://render.githubusercontent.com/render/math?math= p_ {k} - p _ {i} / .p_ {j} - p_{i} ">
ON -SEGMENT <img src="https://render.githubusercontent.com/render/math?math=p_ {i},p_{j},p _{k}">
1 if min.x i ; x j /  x k  max.x i ; x j / and min.y i ; y j /  y k  max.y i ; y j /
2 return TRUE  
3 else return FALSE  
SEGMENTS -INTERSECT works as follows. Lines 1–4 compute the relative orientation <img src="https://render.githubusercontent.com/render/math?math=d_{i}"> of each endpoint <img src="https://render.githubusercontent.com/render/math?math=p_{i}"> with respect to the other segment. If all the relative orientations are nonzero, then we can easily determine whether segments <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{3}"> <img src="https://render.githubusercontent.com/render/math?math=p_{4}"> intersect, as follows. Segment <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> straddles the line containing segment <img src="https://render.githubusercontent.com/render/math?math=p_{3}"> <img src="https://render.githubusercontent.com/render/math?math=p_{4}"> if directed segments <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{2}"> have opposite orientations relative to <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{4}">. In this case, the signs of <img src="https://render.githubusercontent.com/render/math?math=d_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=d_{2}"> differ. Similarly, <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{4}"> straddles the line containing <img src="https://render.githubusercontent.com/render/math?math=p_{1}p_{2}"> if the signs of <img src="https://render.githubusercontent.com/render/math?math=d_{3}"> and <img src="https://render.githubusercontent.com/render/math?math=d_{4}"> differ. If the test of line 5 is true, then the segments straddle each other, and SEGMENTS -INTERSECT returns TRUE .Otherwise, the segments do not straddle each other’s lines, although a boundary case may apply. If all the relative orientations are nonzero, no boundary case applies. All the tests against 0 in lines 7–13 then fail, and SEGMENTS -INTERSECT returns FALSE in line 15. A boundary case occurs if any relative orientation <img src="https://render.githubusercontent.com/render/math?math=d_{k}"> is 0. Here, we know that <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is colinear with the other segment. It is directly on the other segment if and only if it is between the endpoints of the other segment. The procedure ON-SEGMENT returns whether <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is between the endpoints of segment <img src="https://render.githubusercontent.com/render/math?math=p_{i}p_{j}"> , which will be the other segment when called in lines 7–13; the procedure assumes that <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is colinear with segment <img src="https://render.githubusercontent.com/render/math?math=p_{i}p_{j}"> . p 3 is on p 1 p 2 , and so SEGMENTS -INTERSECT returns TRUE in line 12. No endpoints are on other segments in Figure 33.3(d), and so SEGMENTS - INTERSECT returns FALSE in line 15.    
**Determining whether any pair of segments intersects**  
This section presents an algorithm for determining whether any two line segments in a set of segments intersect. The algorithm uses a technique known as “sweeping,” which is common to many computational-geometry algorithms. Moreover, this algorithm, or simple variations of it, can help solve other computational-geometry problems. The algorithm runs in O(n log n) time, where n is the number of segments we are given. It determines only whether or not any intersection exists; it does not print all the intersections. (it takes \omega(n^2) time in the worst case to find all the intersections in a set of n line segments).
\\In sweeping, an imaginary vertical sweep line passes through the given set of geometric objects, usually from left to right. We treat the spatial dimension that the sweep line moves across, in this case the x-dimension, as a dimension of time. Sweeping provides a method for ordering geometric objects, usually by plac- ing them into a dynamic data structure, and for taking advantage of relationships among them. The line-segment-intersection algorithm in this section considers all the line-segment endpoints in left-to-right order and checks for an intersection each time it encounters an endpoint. To describe and prove correct our algorithm for determining whether any two of n line segments intersect, we shall make two simplifying assumptions. First, we assume that no input segment is vertical. Second, we assume that no three input segments intersect at a single point.  
**Ordering Segments**  
As there are no vertical segments, any input segment intersecting a given vertical sweep line intersects it at a single point. Thus, we can order the segments that intersect a vertical sweep line according to the y-coordinates of the points of intersection.  
To be more precise, consider two segments <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> . We say that these segments are comparable at x if the vertical sweep line with x-coordinate x intersects both of them. We say that <img src="https://render.githubusercontent.com/render/math?math=s_{1}" > is above <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> at x, written <img src="https://render.githubusercontent.com/render/math?math=s_{1} <_{x} s_{2}"> , if <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> are comparable at x and the intersection of <img src="https://render.githubusercontent.com/render/math?math=s_{1} "> with the sweep line at x is higher than the intersection of <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> with the same sweep line, or if <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and
<img src="https://render.githubusercontent.com/render/math?math=s{1}"> intersect at the sweep line. for example, we have the relationships <img src="https://render.githubusercontent.com/render/math?math=a  > {r} c , a >_{t} b, b >_{t} c, a >_{t}c and b>_{u}c">. Segment *d* is not comparable with any other segment. For any given *x*, the relation <img src = "https://render.githubusercontent.com/render/math?math=>_ {t} "> is a total preorder for all segments that intersect the sweep line at *x*. That is, the relation is transitive, and if segments <img src = "https://render.githubusercontent.com/render/math?math=s_{1}">and s 2 each intersect the sweep line at x, then either s 1 < x s 
or s 2 < x s 1 , or both (if s 1 and s 2 intersect at the sweep line).is when the sweep line passes through the intersection of two segments? As Figure 33.4(b) shows, the segments reverse their positions in the total preorder. Sweep lines  and w are to the left and right, respectively, of the point of intersection of segments e and f , and we have e < f and f < w e. Note that because we assume that no three segments intersect at the same point, there must be some vertical sweep line x for which intersecting segments e and f are consecutive in the total preorder < x.  
*Moving the sweep line*    
Sweeping algorithms typically manage two sets of data:    
1. The sweep-line status gives the relationships among the objects that the sweep line intersects.  
2. The event-point schedule is a sequence of points, called event points, which we order from left to right according to their x-coordinates. As the sweep progresses from left to right, whenever the sweep line reaches the x-coordinate of an event point, the sweep halts, processes the event point, and then resumes. Changes to the sweep-line status occur only at event points.  
The algorithm determines all the event points before the sweep, based solely on simple properties of the input data. In particular, each segment endpoint is an event point. We sort the segment endpoints by increasing x-coordinate and proceed from left to right. (If two or more endpoints are covertical, i.e., they have
the same x-coordinate, we break the tie by putting all the covertical left endpoints before the covertical right endpoints. Within a set of covertical left endpoints, we put those with lower y-coordinates first, and we do the same within a set of covertical right endpoints.) **fig** When we encounter a segment’s left endpoint, we insert the segment into the sweep-line status, and we delete the segment from the sweep-line status upon encountering its right endpoint. Whenever two segments first become consecutive in the total preorder, we check whether they intersect.   
The sweep-line status is a total preorder T , for which we require the following operations:  
INSERT (T,s): insert segment s into T .  
DELETE (T,s): delete segment s from T .  
ABOVE (T,s): return the segment immediately above segment s in T .  
BELOW (T,s): return the segment immediately below segment s in T .  
If segments <img src = "https://render.githubusercontent.com/render/math?math=s_ {1}"> and <img src = "https://render.githubusercontent.com/render/math?math=s_{2}"> are mutually above each other in the total preorder T ; this situation can occur if <img src = "https://render.githubusercontent.com/render/math?math=s_ {1}"> and <img src = "https://render.githubusercontent.com/render/math?math=s_ {2}"> intersect at the sweep line whose total preorder is given by T . In this case, the two segments may appear in either order in T .  
**Segment-intersection PseudoCode**  
The following algorithm takes as input a set S of *n* line segments, returning the boolean value TRUE if any pair of segments in S intersects, and FALSE otherwise.  
##ANY -SEGMENTS -INTERSECT(S)  
1 T = <img src = "https://render.githubusercontent.com/render/math?math=s\phi">   
2 sort the endpoints of the segments in *S* from left to right, breaking ties by putting left endpoints before right endpoints and breaking further ties by putting points with lower y-coordinates first  
3 **for** each point *p* in the sorted list of endpoints  
4    **if** p is the left endpoint of a segment *s*  
5    INSERT (T,s)  
6    **if** (ABOVE (T,s) exists and intersects *s*) or (BELOW .T; s/ exists and intersects *s*)  
7       return TRUE    
8   **if** *p* is the right endpoint of a segment *s*  
9     **if** both ABOVE (T,s) and BELOW (T,s) exist and ABOVE (T,s) intersects BELOW (T,s)  
10      **return** TRUE  
11    DELETE (T,s)  
12 **return** FALSE  
Line 1 initializes the total preorder to be empty. Line 2 determines the event-point schedule by sorting the 2*n* segment endpoints from left to right, breaking ties as described above. One way to perform line 2 is by lexicographically sorting the endpoints on (*x,e,y*), where *x* and *y* are the usual coordinates, *e*  = 0 for a left endpoint, and *e* = 1 for a right endpoint. Each iteration of the for loop of lines 3–11 processes one event point *p*. If *p* is the left endpoint of a segment *s*, line 5 adds *s* to the total preorder, and lines 6–7 return TRUE if *s* intersects either of the segments it is consecutive with in the total preorder defined by the sweep line passing through *p*. (A boundary condition occurs if *p* lies on another segment *s'* . In this case, we require only that *s* and *s'* be placed consecutively into T.) If *p* is the right endpoint of a segment *s*, then we need to delete *s* from the total preorder. But first, lines 9–10 return TRUE if there is an intersection between the segments surrounding *s* in the total preorder defined by the sweep line passing through *p*. If these segments do not intersect, line 11 deletes segment *s* from the total preorder. If the segments surrounding segment *s* intersect, they would have become consecutive after deleting s had the return statement in line 10 not prevented line 11 from executing. The correctness argument, which follows, will make it clear why it suffices to check the segments surrounding *s*. Finally, if we never find any intersections after having processed all 2n event points, line 12 returns FALSE .
**fig**  
**Finding the convex Hull**  
The convex hull of a set Q of points, denoted by CH(Q), is the smallest convex polygon *P* for which each point in *Q* is either on the boundary of *P* or in its
interior. We implicitly assume that all points in the set *Q* are unique and that *Q* contains at least three points which are not colinear. Intuitively, we can think of each point in *Q* as being a nail sticking out from a board. The convex hull is then the shape formed by a tight rubber band that surrounds all the nails. **ifg**  
In this section, we shall present two algorithms that compute the convex hull of a set of n points. Both algorithms output the vertices of the convex hull in
counterclockwise order. The first, known as Graham’s scan, runs in O(*n* lg *n*) time. The second, called Jarvis’s march, runs in O(*nh*) time, where *h* is the number of vertices of the convex hull. Now, every vertex of CH(Q) is a vertex of Q. Both algorithms use this property.
