 **Line Segments** \\
 Given any two points <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{2}">, then their convex combination is described as <img src="https://render.githubusercontent.com/render/math?math=\alpha"> <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> + <img src="https://render.githubusercontent.com/render/math?math=(1 - \alpha)p_{2}">
 Or to put it simply, convex combination of two points is the set of points lying on the line joining the two points. A directed segment <img src="https://render.githubusercontent.com/render/math?math=\vec{p_{1}p_{2}}"> can be thought of vector from <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> to <img src="https://render.githubusercontent.com/render/math?math=p_{2}">. When we want to know relative orientation of line segments, or if given line segments intersect or not, notion of cross product of two vectors helps. 
 Given two vectors <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{2}">, we can interpret the cross product  <img src="https://render.githubusercontent.com/render/math?math=p_{1}">  <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> as the signed area of the parallelogram formed by the points (0,0),p_{1}, p_{2} , and <img src="https://render.githubusercontent.com/render/math?math=p_{1}+p_{2} = (x_{1} + x_{2}, y_{1}+ y_{2})">. An equivalent definition is given by determinant of the matrix,
 <img src="https://render.githubusercontent.com/render/math?math=p_{1} x p_{2}"> = det<img src="https://render.githubusercontent.com/render/math?math=x_{1}y_{2} - x_{2}y_{1}">
Now, positive cross product implies that  <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> is clockwise from  <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> and vice versa. If cross product is zero, then the vectors are collinear(or parallel, if not taken from a common point). The notion of cross product is useful in :
 1. **Determining whether consecutive segments turn left or right**
 2. **Determining whether two line segments intersect** 
 
 To determine whether two line segments intersect, we check whether each segment *straddles* the line containing the other. A segment <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}">straddles a line if point <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> lies on one side of the line and point <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> lies on the other side. A boundary case arises if <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> or <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> lies directly on the line. Two line segments intersect if and only if either (or both) of the following conditions holds:
 1. Each segment straddles the line containing the other.
 2. An endpoint of one segment lies on the other segment.  
(This condition comes from the boundary case.)
The following procedures implement this idea. SEGMENTS -INTERSECT returns TRUE if segments <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{3}"><img src="https://render.githubusercontent.com/render/math?math=p_{4}"> intersect and FALSE if they do not. It calls the subroutines DIRECTION , which computes relative orientations using the cross- product method above, and ON-SEGMENT , which determines whether a point known to be colinear with a segment lies on that segment.

SEGMENTS -INTERSECT (<img src="https://render.githubusercontent.com/render/math?math=(p_{1},p_{2},p_{3},p_{4})">  
1  <img src="https://render.githubusercontent.com/render/math?math=d_{1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math=(p_{3},p_{4},p_{1})"> 
2  <img src="https://render.githubusercontent.com/render/math?math=d_{2}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_{3},p_{4},p_{1})">
3  <img src="https://render.githubusercontent.com/render/math?math=d_{1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_{3},p_{4},p_{1})">
4  <img src="https://render.githubusercontent.com/render/math?math=d_{1}"> DIRECTION <img src="https://render.githubusercontent.com/render/math?math = (p_{3},p_{4},p_{1})">
5 if ..d 1 > 0 and d 2 < 0/ or .d 1 < 0 and d 2 > 0// and
..d 3 > 0 and d 4 < 0/ or .d 3 < 0 and d 4 > 0//
6
return TRUE
7 elseif d 1 == 0 and O N -SEGMENT .p 3 ; p 4 ; p 1 /
8
return TRUE
9 elseif d 2 == 0 and O N -SEGMENT .p 3 ; p 4 ; p 2 /
10
return TRUE
11 elseif d 3 == 0 and O N -SEGMENT .p 1 ; p 2 ; p 3 /
12
return TRUE
13 elseif d 4 == 0 and O N -SEGMENT .p 1 ; p 2 ; p 4 /
14
return TRUE
15 else return FALSE
DIRECTION .p i ; p j ; p k /
1 return .p k  p i / .p j  p i /
ON -SEGMENT .p i ; p j ; p k /
1 if min.x i ; x j /  x k  max.x i ; x j / and min.y i ; y j /  y k  max.y i ; y j /
2
return TRUE
3 else return FALSE
SEGMENTS -INTERSECT works as follows. Lines 1–4 compute the relative orientation <img src="https://render.githubusercontent.com/render/math?math=d_{i}"> of each endpoint <img src="https://render.githubusercontent.com/render/math?math=p_{i}"> with respect to the other segment. If all the relative orientations are nonzero, then we can easily determine whether segments <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{3}"> <img src="https://render.githubusercontent.com/render/math?math=p_{4}"> intersect, as follows. Segment <img src="https://render.githubusercontent.com/render/math?math=p_{1}"> <img src="https://render.githubusercontent.com/render/math?math=p_{2}"> straddles the line containing segment <img src="https://render.githubusercontent.com/render/math?math=p_{3}"> <img src="https://render.githubusercontent.com/render/math?math=p_{4}"> if directed segments <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{2}"> have opposite orientations relative to <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{4}">. In this case, the signs of <img src="https://render.githubusercontent.com/render/math?math=d_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=d_{2}"> differ. Similarly, <img src="https://render.githubusercontent.com/render/math?math=p_{3}p_{4}"> straddles the line containing <img src="https://render.githubusercontent.com/render/math?math=p_{1}p_{2}"> if the signs of <img src="https://render.githubusercontent.com/render/math?math=d_{3}"> and <img src="https://render.githubusercontent.com/render/math?math=d_{4}"> differ. If the test of line 5 is true, then the segments straddle each other, and SEGMENTS -INTERSECT returns TRUE .Otherwise, the segments do not straddle each other’s lines, although a boundary case may apply. If all the relative orientations are nonzero, no boundary case applies. All the tests against 0 in lines 7–13 then fail, and SEGMENTS -INTERSECT returns FALSE in line 15. A boundary case occurs if any relative orientation <img src="https://render.githubusercontent.com/render/math?math=d_{k}"> is 0. Here, we know that <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is colinear with the other segment. It is directly on the other segment if and only if it is between the endpoints of the other segment. The procedure ON-SEGMENT returns whether <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is between the endpoints of segment <img src="https://render.githubusercontent.com/render/math?math=p_{i}p_{j}"> , which will be the other segment when called in lines 7–13; the procedure assumes that <img src="https://render.githubusercontent.com/render/math?math=p_{k}"> is colinear with segment <img src="https://render.githubusercontent.com/render/math?math=p_{i}p_{j}"> . p 3 is on p 1 p 2 , and so S EGMENTS -I NTERSECT returns TRUE in line 12. No endpoints are on other segments in Figure 33.3(d), and so SEGMENTS - INTERSECT returns FALSE in line 15.
**Determining whether any pair of segments intersects**
This section presents an algorithm for determining whether any two line segments in a set of segments intersect. The algorithm uses a technique known as “sweeping,” which is common to many computational-geometry algorithms. Moreover, this algorithm, or simple variations of it, can help solve other computational-geometry problems. The algorithm runs in O(n log n) time, where n is the number of segments we are given. It determines only whether or not any intersection exists; it does not print all the intersections. (it takes \omega(n^2) time in the worst case to find all the intersections in a set of n line segments).
\\In sweeping, an imaginary vertical sweep line passes through the given set of geometric objects, usually from left to right. We treat the spatial dimension that the sweep line moves across, in this case the x-dimension, as a dimension of time. Sweeping provides a method for ordering geometric objects, usually by plac- ing them into a dynamic data structure, and for taking advantage of relationships among them. The line-segment-intersection algorithm in this section considers all the line-segment endpoints in left-to-right order and checks for an intersection each time it encounters an endpoint. To describe and prove correct our algorithm for determining whether any two of n line segments intersect, we shall make two simplifying assumptions. First, we assume that no input segment is vertical. Second, we assume that no three input segments intersect at a single point.
**Ordering Segments**
As there are no vertical segments, any input segment intersecting a given vertical sweep line intersects it at a single point. Thus, we can order the segments that intersect a vertical sweep line according to the y-coordinates of the points of intersection.
To be more precise, consider two segments <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> . We say that these segments are comparable at x if the vertical sweep line with x-coordinate x intersects both of them. We say that <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> is above <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> at x, written <img src="https://render.githubusercontent.com/render/math?math=s_{1} <_{x} s_{2}"> , if <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> are comparable at x and the intersection of <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> with the sweep line at x is higher than the intersection of <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> with the same sweep line, or if <img src="https://render.githubusercontent.com/render/math?math=s_{1}"> and <img src="https://render.githubusercontent.com/render/math?math=s_{2}"> intersect at the sweep line. for example, we have the relationships a < r c, a < t b, b < t c, a < t c, and b < u c. Segment d is not comparable with any other segment.when the sweep line passes through the intersection of two segments? As Figure 33.4(b) shows, the segments reverse their positions in the total preorder. Sweep lines  and w are to the left and right, respectively, of the point of intersection of segments e and f , and we have e <  f and f < w e. Note
that because we assume that no three segments intersect at the same point, there must be some vertical sweep line x for which intersecting segments e and f are consecutive in the total preorder < x.
*Moving the sweep line*
Sweeping algorithms typically manage two sets of data:
1. The sweep-line status gives the relationships among the objects that the sweep line intersects.
2. The event-point schedule is a sequence of points, called event points, which we order from left to right according to their x-coordinates. As the sweep progresses from left to right, whenever the sweep line reaches the x-coordinate of an event point, the sweep halts, processes the event point, and then resumes. Changes to the sweep-line status occur only at event points
